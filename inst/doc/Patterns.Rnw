\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{apalike}
\usepackage{natbib}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\title{Vignette : the Patterns package} \author{Fr\'ed\'eric Bertrand, Nicolas Jung, Laurent Vallat, Myriam Maumy-Bertrand}


\usepackage{hyperref}
\newcommand{\crod}{]\!]}
\newcommand{\degree}{\,^{\circ}}
\newcommand{\crog}{[\![}
\newcommand{\mv}{\varepsilon}
\newcommand{\IntervalleDiscret}[2]{\crog#1,#2\crod}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}

\begin{document} 
\SweaveOpts{concordance=TRUE}
\maketitle


\tableofcontents

<<echo=false,results=hide>>=
options(width=60)
options(continue="   ")
@


\section{Overview}


In a cell, after a specific activation, a gene contained in the DNA can be expressed as RNA molecules that are later traduced in proteins that will sustain the cell response \cite{crick1970central}.\\

Cells are in continuous contact with their environment within the organism and display an adapted response to its modifications \cite{barabasi2004network}.  For this, each transient environmental modification activates surface cell receptors (and co-receptors) that induce multiple integrated signaling cascades whose ultimate events are expression of specific genes and proteins (transcriptional factors). These first transcriptional factors (TF) induce the expression of other genes within the cell. Some of these genes code themselves for TF or transcriptional regulators (TR) that induce sequential activation of other genes. At the end, concerted expression of these multiple genes induces protein expressions that are the substratum of the adapted cellular reaction to the initial stimulus.\\

One Common tool to analyze such complex systems is regulatory networks (RN). When studying transcriptional data, this RN is called a gene regulatory network (GRN) in which the vertex represent genes and edges represent potential (orientated) interactions between these genes. \\

Since the emergence of high-throughput technologies that allow measuring simultaneously expression of thousands of genes, many tools have been developed to learn gene expression profiles and reverse-engineer their underlying gene regulatory network (GRN) (\citealp{Bansal07}). 
These tools are either based on static co-expression methods or, if the biological phenomenon shows any temporality, time dependent methods. 
While the former relies on the assumption that co-expressed genes share some biological characteristics, the latter is grounded on a directed network with temporal dependencies. 

The \verb?Patterns? package is a tool designed to infer such directed networks with temporal dependencies.

Another important distinction should be made between exogenous stress (e.g., growth response) and endogenous phenomenon (e.g., cell cycle) (\citealp{Zhu07} and \citealp{Lusc04}). This leads to different network topologies: in exogenous stress, networks' topologies seem to have larger hubs and shorter paths through temporal dependant transcriptional waves. This results in a quick response to environmental modifications (\citealp{Lusc04}) and those networks are often called ``cascade networks''.

The \verb?Patterns? package is based on the idea that genes may be assigned to temporal clusters which are used to enforce temporal causality in the network. It has been designed to analyze temporal microarray datasets, allowing gene selection, temporal cluster assignment, reverse-engineering of the GRN and predicting the effect of biological intervention experiments.
This package also features a temporal synthetic simulation tool. The biological interpretations are made easier and comprehensive thanks to graphical outputs.



\begin{figure}
\centering
\includegraphics{casc.pdf}
\caption{Cascade networks are temporal nested networks} \label{casc}
\end{figure}

The \verb?Patterns? package is a tool to analyze microarray data and model directed networks with temporal dependencies. %The statistical tools provided in this library show several major improvements over those that were initially published in \cite{vallat2013reverse}.

\section{Installation requirements}

Following software is required to run the \verb?Patterns? package:

\begin{itemize}
\item R (> 2.14.2). For installation of R, refer to http://www.r-project.org.
\item R-packages: \texttt{abind} ; \texttt{animation} ; \texttt{cluster} ; \texttt{datasets} ; \texttt{graphics} ; \texttt{grDevices} ; \texttt{igraph} ; \texttt{lars} ; \texttt{lattice} ; \texttt{limma}* ; \texttt{magic} ; \texttt{methods} ; \texttt{nnls} ; \texttt{plotrix} ; \texttt{splines} ; \texttt{stats} ; \texttt{stats4} ; \texttt{survival}* ; \texttt{tnet} ; \texttt{utils} ; \texttt{VGAM}. 
\end{itemize}

\noindent
To install them :

\begin{itemize}
\item without stars: 
<<eval=false>>=
install.packages("name_of_the_package")
@
\item with one star:
<<eval=false>>=
source("http://bioconductor.org/biocLite.R")
biocLite("name_of_the_package")
@
\end{itemize}

\noindent
Once the \verb?Patterns? package is installed, you can load the package by: 

<<results=hide>>=
library(Patterns)
@

\section{Data pre-processing}

To illustrate our approach  we will analyze a microarray data set. This data data set has initially be published in \cite{vallat2007temporal}. Our data set is separated in two files: the first, \texttt{micro\_S},  corresponds to the stimulated gene expressions while the second, \texttt{micro\_US}, corresponds to the unstimulated gene expressions. In other words, \texttt{micro\_US} is the control data set. You can load these data by:


<<>>=
data(micro_S)
data(micro_US)
@



Each of the these data sets corresponds to \Sexpr{dim(micro_S)[1]} genes measured through 4 time points and 6 subjects (we have repeated longitudinal data). These data have have for biological model chronic lymphocytic leukemia ; for further details, see \cite{vallat2007temporal} or \cite{vallat2013reverse}. \\

These data need to be coerced into a \texttt{micro\_array} class.  The matrix with the microarray measurements has to be of size $N \times K$ where $N$ is the number of genes and $K=T \times P$ where $T$ stands for the number of time points and $P$ for the number of subjects. The first $T$ colomns are the gene expressions for subject $1$, the following $T$ are the gene expressions for subject $2$... In our case:

<<>>=
colnames(micro_S)
@

To coerce the data toward a \texttt{micro\_array} class, you may just use the \texttt{as.micro\_array} function:
<<>>=
micro_S<-as.micro_array(micro_S,time=c(60,90,210,390),subject=6)
micro_US<-as.micro_array(micro_US,time=c(60,90,210,390),subject=6)
@


In addition of the matrix of microarray measurements, this class also contains the name of genes, their group, the first time at which they are expressed, the time points at which they are measured, and the number of subjects. Primarily, method \texttt{print} summarizes these informations:

<<>>=
print(micro_S)
@

While method \texttt{print} gives the structure of the object, method \texttt{head} gives an overview of the data:

<<>>=
head(micro_S)
@

Entries \texttt{Vector of group} and \texttt{Vector of starting time} are set to $0$ because they are no yet defined. They will be completed automatically when using gene selection functions of this package. Otherwise, it should be completed by the user. \\

Once data coerced into the \texttt{micro\_array} class, this package allows doing gene selection and reverse-engineering ; note that gene selection requires two sets of data and will select genes that are differentially expressed in one condition against the other. 



\section{Gene selection}


Gene selection requires two sets of data and will select genes that are differentially expressed in one condition against the other ; if unstimulated control dataset is omitted, it is remplaced with a null data set. \\ 


In this package gene selection mainly relies on the R-bioconductor \texttt{limma} package \cite{limma}. The \texttt{limma} package allows selecting genes that are differentially expressed between two conditions. In our case, these two conditions are ``\textit{stimulated}" and ``\textit{unstimulated}". The method relies on linear models and on improved bayesian t-tests ; refer to \cite{limma} for details.  Basically, to find the 50 more significant expressed genes you will use:

<<>>=
Selection<-geneSelection(M1=micro_S,M2=micro_US,tot.number=50,data_log=TRUE)
@

The \texttt{data\_log} option (default to TRUE) indicates that the data are logged before analysis. This function returns an object of class \texttt{micro\_array}, with the difference ``stimulated" (S) minus `unstimulated" (US) of the 50 more significant expressed genes ; as the \texttt{data\_log} option is here activated, we get: 

$$
\log(S) - \log(US) = \log\left(\frac{S}{US}\right).
$$

Notice that the \texttt{group} and \texttt{start\_time} are filled out automatically. \\

Applying the \texttt{summary} method prints the structure of Pearson linear correlation for subjects (see graphic \ref{ind}) and the structure of Pearson linear correlation for genes (see graphic \ref{ind2}): 

<<keep.source=TRUE,results=hide>>=
summary(Selection)
@


\begin{figure}
\centering
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
summary(Selection,nb.graph=2)
@
\caption{Correlation between subjects}\label{ind}
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
summary(Selection,nb.graph=3)
@
\caption{Correlation between genes}\label{ind2}
\end{figure}





Note that a hierarchical clustering (function \texttt{agnes} of package \texttt{cluster}) is performed before plotting the result. This is necessary to point out some structures, as correlated objects will be close in the graph. \\

If we want to select genes that are differentially expressed at specific time points we use the option \texttt{wanted.patterns}:


<<keep.source=TRUE>>=
#If we want to select genes that are differentially 
#at time t60 or t90 :
Selection<-geneSelection(M1=micro_S,M2=micro_US,tot.number=30,
wanted.patterns=
rbind(c(0,1,0,0),c(1,0,0,0),c(1,1,0,0)))
@

You may want forbid some patterns thanks to the \texttt{forbidden.patterns} option. \\

If we wish select genes that have a differential maximum of expression at a specific time point, we may use the \texttt{genePicSelection} method. Basically, this function selects genes that are differentially expressed at desired time point, and which differential expression is significantly higher at this time point:

<<>>=
Selection<-genePicSelection(M1=micro_S,M2=micro_US,1,
abs_val=FALSE,alpha_diff=0.01)
@

We can now compute a effective selection. As shown in graphic \ref{finalselec}, the early time points ($t_1=$\Sexpr{micro_S@time[1]} and $t_2=$\Sexpr{micro_S@time[2]}) are correlated together and the later time points  ($t_3=$\Sexpr{micro_S@time[3]} and $t_4=$\Sexpr{micro_S@time[4]}) are correlated together ; this is a fact that is well known in the literature \cite{yosef2011impulse}. As early genes expressions are lower than later gene expressions, we select them separately:

<<keep.source=TRUE>>=
#Select early genes (t1 or t2)
Selection1<-geneSelection(M1=micro_S,M2=micro_US,20,
wanted.patterns=
rbind(c(0,1,0,0),c(1,0,0,0),c(1,1,0,0)))

#Section genes with first significant differential 
#expression at t1:

Selection2<-geneSelection(M1=micro_S,M2=micro_US,20,
pic=1)

#Section genes with first significant differential 
#expression at t2:

Selection3<-geneSelection(M1=micro_S,M2=micro_US,20,
pic=2)

#Select later genes (t3 or t4)
Selection4<-geneSelection(M1=micro_S,M2=micro_US,50,
wanted.patterns=
rbind(c(0,0,1,0),c(0,0,0,1),c(1,1,0,0)))
@

We then make the union between these different selection:

<<keep.source=TRUE>>=
Selection<-unionMicro(Selection1,Selection2)
Selection<-unionMicro(Selection,Selection3)
Selection<-unionMicro(Selection,Selection4)
print(Selection)
@
<<keep.source=TRUE,results=hide>>=
#Prints the correlation graphics Figure 4:
summary(Selection,3)
@

\begin{figure}
\centering
<<width=50,fig=TRUE,height=50,results=hide,echo=FALSE>>=
summary(Selection,3)
@
\caption{Correlation structure of the final selection}
\label{finalselec}
\end{figure}


<<keep.source=TRUE,results=hide>>=
Selection2gp<-unionMicro(Selection1,Selection2)
Selection2gp<-unionMicro(Selection2gp,Selection3)
@

\section{Gene regulatory network reverse engineering}
\subsection{Theorical background}
Gene regulatory network reverse engineering relies on a lasso penalized regression \cite{tib}. The Lasso estimation is given by:
\begin{equation}\label{lasso1}
\hat{\boldsymbol{\beta}}^L(\lambda)=\underset{{\boldsymbol{\beta}} \in \mathbb{R}^p}{\operatorname{argmin}} \left[ \sum_{i=1}^{N} \left(y_i- \sum_{j=1}^{p} {\beta}_j  x_{ij}\right)^2 +  \lambda \| \boldsymbol{\beta}\|_1\right],
\end{equation}

with $\lambda$ a non negative scalar that determines the level of the constraints. We remark that:

\begin{itemize}
\item When $\lambda = 0$, $\hat{\boldsymbol{\beta}}^L$ is ordinary least square estimation.
\item When $\lambda = +\infty$, we get $\hat{\boldsymbol{\beta}}^L = \boldsymbol{0}_p$.
\end{itemize}

The Lasso regression has two main advantages : 

\begin{enumerate}
\item it allows dealing with ill posed problems, where the number of observations is inferior to the number of variables,
\item it allows performing variable selection. \\
\end{enumerate}

The Lasso regression can also be written in the following form: 

\begin{equation}\label{lasso2}
\hat{\boldsymbol{\beta}}^L(\lambda)=\underset{{\boldsymbol{\beta}} \in \mathbb{R}^p ~~ \| \boldsymbol{\beta}\|_1 \leq \tilde{\lambda}}{\operatorname{argmin} } \left[ \sum_{i=1}^{N} \left(y_i- \sum_{j=1}^{p} {\beta}_j  x_{ij}\right)^2 \right].
\end{equation}

These two forms (equation \eqref{lasso1} and \eqref{lasso2}) are equivalent in the sense that for each non negative $\lambda$ there exists a non negative  $\tilde{\lambda}$ leading to the same solution. \\


Based on the Lasso regression (equation \ref{lasso2}), our model is very close to the model proposed in \cite{vallat2013reverse}. It can be written: 
\begin{equation*} 
\underset{\omega_{ij} \in \mathbb{R},~1\leq i,j\leq N_{sel}}{\operatorname{argmin} }\left[ \sum_{j=1}^{N_{sel}}\left(\tilde{\boldsymbol{x}}_{jp.} - \sum_{i=1}^{N_{sel}} F_{m(i)m(j)} \omega_{ij} \boldsymbol{x}_{ip.}\right)^2\right],
\end{equation*}

with the constraint : 

$$
\forall j = 1,...,N_{sel}, ~~~ \sum_{i=1}^{N_{sel}} \omega_{ij} \leq {\lambda_j},
$$

where:
$$
\tilde{\boldsymbol{x}}_{jp.} = 
\begin{pmatrix}
x_{jp{t_1}} \\
\vdots \\
x_{jp{t_T}}
\end{pmatrix}
\text{~~~and~~~}
\boldsymbol{x}_{ip.} = 
\begin{pmatrix}
x_{jp{t_1}} \\
\vdots \\
x_{jp{t_{T}}}
\end{pmatrix},
$$

with: 

\begin{itemize}
\item $x_{jp{t_k}}$ is the expression of gene $j$ for patient $p$ at time point $t_k$,
\item $m(\bullet)$ is the function that maps a gene to its categorical label,
\item $F_{m(i)m(j)}$ is a $N_{gp}$ squared matrix that describes the action of genes,
\item $\omega_{ij}$ is the strength of the connection from gene $i$ toward gene $j$,
\item $\lambda_1$,...,$\lambda_j$ are non negative constants.
\end{itemize} 

So, $\tilde{\boldsymbol{x}}_{jp.}$ is the regulated gene and $\boldsymbol{x}_{ip.}, i=1..N$ are the regulators. Notice that matrix $F_{m(i)m(j)}$ permits to the link between genes $i$ and $j$ to evolves across time.For the time being, we do not allow auto-regulations for genes ($m(i) = m(j) \Rightarrow F_{m(i)m(j)} = 0$).




We solve this problem to a coordinate ascent approach, by iteratively supposing the $F$ matrices or the $\omega_{ij}$ matrices known. The result of the optimization is a connectivity network described by the nonzero elements of  $\omega_{ij}$ combined with a set of cluster-dependent interaction models described by the set $F_{m(i)m(j)}$.\\

However, if clusters are sufficiently homogeneous, inference of matrices $F_{m(i)m(j)}$ doesn't depend on which genes are active (i.e. which $\omega_{ij} \neq 0$). That's why a non iterative algorithm is proposed in which estimation of   of matrices $F_{m(i)m(j)}$  precedes estimation of matrix $\Omega$.\\

To get a more robust result, at each step, the estimation of matrices $F_{m(i)m(j)}$ is done several times throughout cross-validation. Furthermore, to avoid computational issues, the new solution is chosen by a linear combination between the old and the new solution. 


The three functions \verb?replaceBand?, \verb?replaceUp? and \verb?replaceDown? can be used to create $F$ matrices with custom band values. The two functions \verb?CascadeFinit? and \verb?CascadeFshape? will provide the users with band $F$ matrices useful for cascade networks.



\subsection{Performing the algorithm}

To perform this algorithm on our data:

<<keep.source=TRUE,eval=FALSE>>=
network<-inference(Selection)
networkCascade<-inference(Selection,Finit=CascadeFinit(4,4),Fshape=CascadeFshape(4,4))
network2gp<-inference(Selection2gp)
@
<<echo=FALSE,results=hide>>=
load(system.file("extdata", "networks.Rdata", package = "Patterns"))
@


We can plot the resulting network (figure \ref{net1}) and a representation of $F$ matrices (figure \ref{F1}) simply using the \texttt{plot} method:
<<keep.source=TRUE,eval=FALSE>>=
plot(network,choice="F")
plot(networkCascade,choice="F")
plot(network2gp,choice="F")
plot(network,choice="network",gr=Selection@group)
plot(network2gp,choice="network",gr=Selection2gp@group)
@

Note that all network plots are computed using the Igraph R package \cite{igraph}. \\ 
\begin{figure}
\centering
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
plot(network,choice="F")
@
\caption{The F matrices}\label{F1}
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
plot(networkCascade,choice="F")
@
\caption{The F matrices}\label{F1Casc}
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
plot(network2gp,choice="F")
@
\caption{The F matrices}\label{F1gp}
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
plot(network,choice="network",gr=Selection@group)
@
\caption{The resulting network with all edges}\label{net1}
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
plot(network2gp,choice="network",gr=Selection2gp@group)
@
\caption{The resulting network with all edges}\label{net1gp}
\end{figure}


The number of edges in the network makes the message difficult to interpret ; and as we shall see in the next section, results in term of predictive positive value and F-score can be improved when choosing a right cutoff level. Using the \texttt{nv} option, we shall choose a cutoff under which the regression coefficients ($\omega_{ij}$) are set to $0$. In figure \ref{net2} a cutoff of 0.2 is chosen. 

\subsection{Choosing the cutoff}

The difficulty is now to choose the best cutoff. As a starting point, we propose method \texttt{evolution}, that allows the user to see, in a html page, the evolution of the network when the cutoff is growing up. When the \texttt{fix} option is set to \texttt{FASLE}, at each step the position of the genes are re-calculated. 

<<keep.source=TRUE,eval=FALSE>>=
evolution(network,seq(0,0.4,by=0.01),gr=Selection@group,fix=TRUE)
evolution(network,seq(0,0.4,by=0.01),gr=Selection@group,fix=FALSE)
@

To see the result of these functions, go to :

\begin{itemize}
\item \url{http://www-irma.u-strasbg.fr/~njung/evolution_fix_true/evol.html} : here the \texttt{fix} option is set to \texttt{TRUE}.
\item \url{http://www-irma.u-strasbg.fr/~njung/evolution_fix_false/evol.html}: here the \texttt{fix} option is set to \texttt{FALSE}.
\end{itemize}

As it is well known, gene regulatory networks are scale-free \cite{jeong2000large}. The notion of scale freeness in networks relies on the probability distribution of the number of outgoing edges. A network is called scale free when this distribution is a power law distribution \cite{clauset2009power}. As this family of law is large, it is difficult to test such an hypothesis. We used the test proposed in \cite{clauset2009power}:


%chunk 26
<<keep.source=TRUE>>=
evol_cutoff<-cutoff(network)
nv<-0.07
@


We prefer plotting the smooth interpolation rather than the exact values, as our interest relies mostly on the trend. In figure \ref{eve}, if we apply some heuristic scree test, we will choose a cutoff of $nv=0.07$.   

\begin{figure}
\centering
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
plot(network,choice="network",gr=Selection@group,nv=0.07)
@
\caption{The resulting network with a cutoff of 0.07}\label{net2}
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE,results=hide>>=
plot(evol_cutoff$sequence,evol_cutoff$p.value.inter,type="l",xlab="cutoff",ylab="p.value")
@
\caption{Evolution of scale freeness of the network in function of the cutoff. The p-value corresponds to the adequacy of the data to a power law distribution. }\label{eve}
\end{figure}

\subsection{Analyzing the network}

One may want to know which genes are important in the network. In our representation, the bigger the vertex the larger the number of outgoing edges. Indeed, genes with many outgoing edges, the hubs, are important in the network. But what about genes that control these hubs ? The \texttt{analyze\_network} method allows computing different indicators:

\begin{itemize}
\item betweenness : it is a measure of the node centrality. It is calculated, for node $n$, by the following formula: 
$$
\sum_{s\neq t \neq n}\frac{\sigma_{st}(n)}{\sigma_{st}}
$$

where $\sigma_{st}$ is the number of shortest way between $s$ and $t$, and $\sigma_{st}(n)$ is the number of shortest way between $s$ and $t$ passing by $n$ ;
\item degree : the number of outgoing edges ;
\item output : the sum of weights of outgoing genes ;
\item closeness : it is a measure of the distance (in terms of shortest path) of a gene to others.
\end{itemize}

As our network is weighted we used specific measures developed in \cite{bla}.
 
<<keep.source=TRUE>>=
#analyze<-analyze_network(network,nv)
#head(analyze)
@

Note that one can plot the network and modulate the size of the vertex following one of this measure, using the \texttt{weight.node} option. \\

Using again the package \texttt{animation}, we can see how the signal spreads in the network by turning to \texttt{TRUE} the option \texttt{ani}:

<<keep.source=TRUE,eval=FALSE>>=
plot(network,nv=nv,gr=Selection@group,ani=TRUE)
@ 

Result is available at \url{http://www-irma.u-strasbg.fr/~njung/network_spread/spread.html}. \\


The method \texttt{plot} has basically two steps: 1- it calculates the position of the vertex, 2- it plots the graph. In some case, it is interesting to produce two plots of a same network without changing vertex positions. Here is a way to do that, using the \texttt{ini} option of method plot:

<<keep.source=TRUE,eval=FALSE>>=
P<-position(network,nv=nv)
#plotting the network with the group coloring:
plot(network,nv=nv,gr=Selection@group,ini=P)
#plotting the network without the group coloring:
plot(network,nv=nv,ini=P)
@ 
<<keep.source=TRUE,echo=FALSE>>=
P<-position(network,nv=nv)
@ 


However, we didn't develop all possibilities of the \texttt{plot} option ; for more possibilities, please refer to the manual. \\


\section{Prediction}

Once the network reverse-engineered, we want to be able to know the impact of perturbation in this network. For example, what would happen if gene 16 is perturbed ? First the \texttt{geneNeighborhood} method allows determining which are the neighborhood of gene 16. \\

<<keep.source=TRUE,eval=FALSE>>=
geneNeighborhood(network,targets=16,nv=nv,ini=P,
	label.hub=TRUE,label_v=Selection@name)
#label.hub: only hubs vertex should have a name
#label_v: name of the vertex
@ 


We then can predict the changes in the gene expression. Suppose gene 16 is knocked-out
%chunk 34
<<keep.source=TRUE>>=
prediction_ko16<-predict(Selection,network,nv=nv,targets=16)
prediction_ko16_2gp<-predict(Selection2gp,network2gp,nv=nv,targets=16)
@

We can then plot the result: 
<<keep.source=TRUE,eval=FALSE>>=
#We plot the results ; here for example we see changes at time point t2
plot(prediction_ko16,time=2,ini=P,label.hub=TRUE,label_v=Selection@name)
plot(prediction_ko16_2gp,time=2,ini=P,label.hub=TRUE,label_v=Selection2gp@name)
@ 

\begin{figure}
\centering
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE>>=
geneNeighborhood(network,targets=16,nv=nv,ini=P,label.hub=TRUE,label_v=Selection@name)
@
\caption{Neighborhood of gene 16} \label{neig}
<<fig=TRUE,results=hide,width=4,height=4,echo=FALSE>>=
plot(prediction_ko16,time=2,ini=P,label.hub=TRUE,label_v=Selection@name)
@
\caption{Perturbation of the network consecutively to the knock out of gene 16 at time point 2.} \label{pred}
<<fig=TRUE,results=hide,width=4,height=4,echo=FALSE>>=
plot(prediction_ko16_2gp,time=2,ini=P,label.hub=TRUE,label_v=Selection2gp@name)
@
\caption{Perturbation of the network consecutively to the knock out of gene 16 at time point 2.} \label{pred2gp}
\end{figure}


\section{Simulation}

To simulate gene expressions based on a gene regulatory network, we first have to generate the network. Here, we implemented an algorithm that is inspired by the \textit{preferential attachment} from Barabasi \cite{jeong2007measuring}. We adapted this algorithm in our case of temporal nested networks. \\

We then use our linear model to make some simulations, using Laplace laws to initiate the algorithm.  


<<keep.source>>=
#We set the seed to make the results reproducible 
set.seed(1)

#We create a random scale free network
Net<-network_random(
	nb=100,
	time_label=rep(1:4,each=25),
	exp=1,
	init=1,
	regul=round(rexp(100,1))+1,
	min_expr=0.1,
	max_expr=2,
	casc.level=0.4
	)

#We change F matrices
ngrp<-4
T<-4 
F<-array(0,c(T,T,ngrp*ngrp))
for(i in 1:(ngrp*ngrp)){diag(F[,,i])<-1}
F[,,2]<-F[,,2]*0.2
F[2,1,2]<-1
F[3,2,2]<-1
F[,,4]<-F[,,2]*0.3
F[3,1,4]<-1
F[,,5]<-F[,,2]
Net@F<-F

#We simulate gene expression according to the network Net
M<-gene_expr_simulation(
	network=Net,
	time_label=rep(1:4,each=25),
	subject=5,
	level_pic=200)
@

<<keep.source,echo=FALSE>>=
load(system.file("extdata", "Net_inf2.RData", package = "Patterns"))
Net_inf<-Net_inf2
@

<<keep.source,eval=FALSE>>=
#We infer the new network
Net_inf<-inference(M)
@

<<keep.source>>=
#Comparing true and inferred networks
F_score<-rep(0,200)
#Here are the cutoff level tested
test.seq<-seq(0,max(abs(Net_inf@network*0.9)),length.out=200)

u<-0
for(i in test.seq){
	u<-u+1
	F_score[u]<-compare(Net,Net_inf,i)[3]
}
@


<<keep.source>>=
#Choosing the cutoff
cut.seq<-cutoff(Net_inf)
plot(cut.seq$sequence,cut.seq$p.value.inter)
@

\newpage

\begin{figure}
\centering
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE>>=
plot(cut.seq$sequence,cut.seq$p.value.inter,type="l",xlab="cutoff",ylab="p.value")
abline(v=0.24,col="red")
@
\caption{Evolution of the scale freeness of the network in function of the cutoff} \label{pred}
<<fig=TRUE,results=hide,width=8,height=8,echo=FALSE>>=
plot(test.seq,F_score,type="b",xlab="cutoff",ylab="Fscore")
abline(v=0.24,col="red")
@
\caption{Evolution of F-score in function of the cutoff} \label{pred}
\end{figure}

\begin{figure}
\centering
\includegraphics{subject_evol}
\caption{Evolution of F-score in function of the cutoff and the number of subject in the study} \label{pred22}
\end{figure}

\newpage
\bibliographystyle{apalike}
%\bibliography{vignette} 
\begin{thebibliography}{}

\bibitem[Bansal et~al., 2007]{Bansal07}
Bansal, M., Belcastro, V., Ambesi-Impiombato, A., and Di~Bernardo, D. (2007).
\newblock How to infer gene networks from expression profiles.
\newblock {\em Molecular systems biology}, 3(1).

\bibitem[Barab{\'a}si and Oltvai, 2004]{barabasi2004network}
Barab{\'a}si, A.-L. and Oltvai, Z.~N. (2004).
\newblock Network biology: understanding the cell's functional organization.
\newblock {\em Nature Reviews Genetics}, 5(2):101--113.

\bibitem[Clauset et~al., 2009]{clauset2009power}
Clauset, A., Shalizi, C.~R., and Newman, M.~E. (2009).
\newblock Power-law distributions in empirical data.
\newblock {\em SIAM review}, 51(4):661--703.

\bibitem[Crick et~al., 1970]{crick1970central}
Crick, F. et~al. (1970).
\newblock Central dogma of molecular biology.
\newblock {\em Nature}, 227(5258):561--563.

\bibitem[Csardi and Nepusz, 2006]{igraph}
Csardi, G. and Nepusz, T. (2006).
\newblock The igraph software package for complex network research.
\newblock {\em InterJournal}, Complex Systems:1695.

\bibitem[Jeong et~al., 2007]{jeong2007measuring}
Jeong, H., N{\'e}da, Z., and Barab{\'a}si, A.-L. (2007).
\newblock Measuring preferential attachment in evolving networks.
\newblock {\em EPL (Europhysics Letters)}, 61(4):567.

\bibitem[Jeong et~al., 2000]{jeong2000large}
Jeong, H., Tombor, B., Albert, R., Oltvai, Z.~N., and Barab{\'a}si, A.-L.
  (2000).
\newblock The large-scale organization of metabolic networks.
\newblock {\em Nature}, 407(6804):651--654.

\bibitem[Luscombe et~al., 2004]{Lusc04}
Luscombe, N.~M., Babu, M.~M., Yu, H., Snyder, M., Teichmann, S.~A., and
  Gerstein, M. (2004).
\newblock Genomic analysis of regulatory network dynamics reveals large
  topological changes.
\newblock {\em Nature}, 431(7006):308--312.

\bibitem[Opsahl, 2009]{bla}
Opsahl, T. (2009).
\newblock {\em Structure and Evolution of Weighted Networks}.
\newblock University of London (Queen Mary College), London, UK.

\bibitem[Smyth, 2005]{limma}
Smyth, G.~K. (2005).
\newblock Limma: linear models for microarray data.
\newblock In Gentleman, R., Carey, V., Dudoit, S., Irizarry, R., and Huber, W.,
  editors, {\em Bioinformatics and Computational Biology Solutions using R and
  Bioconductor}, pages 397--420. Springer, New York.

\bibitem[Tibshirani, 1996]{tib}
Tibshirani, R. (1996).
\newblock Regression shrinkage and selection via the lasso.
\newblock {\em Journal of the Royal Statistical Society. Series B
  (Methodological)}, pages 267--288.

\bibitem[Vallat et~al., 2013]{vallat2013reverse}
Vallat, L., Kemper, C.~A., Jung, N., Maumy-Bertrand, M., Bertrand, F., Meyer,
  N., Pocheville, A., Fisher, J.~W., Gribben, J.~G., and Bahram, S. (2013).
\newblock Reverse-engineering the genetic circuitry of a cancer cell with
  predicted intervention in chronic lymphocytic leukemia.
\newblock {\em Proceedings of the National Academy of Sciences},
  110(2):459--464.

\bibitem[Vallat et~al., 2007]{vallat2007temporal}
Vallat, L.~D., Park, Y., Li, C., and Gribben, J.~G. (2007).
\newblock Temporal genetic program following b-cell receptor cross-linking:
  altered balance between proliferation and death in healthy and malignant b
  cells.
\newblock {\em Blood}, 109(9):3989--3997.

\bibitem[Yosef and Regev, 2011]{yosef2011impulse}
Yosef, N. and Regev, A. (2011).
\newblock Impulse control: temporal dynamics in gene transcription.
\newblock {\em Cell}, 144(6):886--896.

\bibitem[Zhu et~al., 2007]{Zhu07}
Zhu, X., Gerstein, M., and Snyder, M. (2007).
\newblock Getting connected: analysis and principles of biological networks.
\newblock {\em Genes \& development}, 21(9):1010--1024.

\end{thebibliography}
\end{document}